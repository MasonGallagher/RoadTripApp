package com.GRP.Group5.RoadTripApp.Scheduling;

import com.GRP.Group5.RoadTripApp.utils.Functions;
import com.GRP.Group5.RoadTripApp.utils.Plan;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;

/**
 * Created by Ben Clark on 10/04/2018.
 */

class SchedulePermutationGenerator {

    List<SchedulablePlace> lodgings, food, attractions, subPlaces;

    List<SchedulablePlace>[] masterTable;

    Plan firstPermutation;

    int startTime;
    int currentTime;
    int permutation;
    int recursiveCounter;
    private int extraHours;
    private Date startDate;

    /**
     * Initialisation of generator
     * @param lodgings places that are classed as lodgings - ie hotels
     * @param food places where you can get food
     * @param attractions places that are tourist attractions
     * @param subPlaces any other places (mostly empty)
     * @param currentTime time that permutations can begin scheduling from
     * @param date date to start scheduling at
     */
    public SchedulePermutationGenerator(List<SchedulablePlace> lodgings, List<SchedulablePlace> food, List<SchedulablePlace> attractions, List<SchedulablePlace> subPlaces, int currentTime, Date date) {
        //Lists
        this.lodgings = lodgings;
        this.food = food;
        this.attractions = attractions;
        this.subPlaces = subPlaces;

        //Time and date
        this.currentTime = this.roundToLowestHour(currentTime);
        this.startTime = this.currentTime;
        this.startDate = date;

        //permutations
        this.firstPermutation = null;
        this.permutation = 0;

        //other
        this.masterTable = this.createMasterTable();
        this.recursiveCounter = 0;
        this.extraHours = 0;
    }

    /**
     * rounds currentTime (in minutes) to the lowest hour
     * ie roundToLowestHour(1685) = 4
     * @param currentTime MINUTES
     * @return the minutes converted into the lowest hour
     */
    private int roundToLowestHour(int currentTime) {
        //convert to 24 hour
        int hour = (int) Math.floor(currentTime / 60.0);
        while(hour >= 24){
            hour -= 24;
        }
        return hour;
    }

    /**
     * user to extend the time that the system has been allocated to generate a permutation within
     * @param amount - amount extra to extend by
     * @return total time extending by
     */
    public int addExtraHours(int amount){
        this.extraHours += amount;
        this.masterTable = this.createMasterTable();
        return this.extraHours;
    }

    /**
     * returns the first permutation generated by the system
     * not necessarily has permutation = 1
     * @return the first permutation
     */
    public Plan firstPermutation() {
        if (this.firstPermutation == null) {
            this.firstPermutation = nextPermutation();
        }
        return this.firstPermutation;
    }

    /**
     * Creates a "master table" this is an array of lists that indicate which places are open at which times
     * Hence when each place can be scheduled
     * @return array of lists of schedulable places
     */
    public List<SchedulablePlace>[] createMasterTable(){
        //assume hotels are open 24/7 (they usually are)
        int nights = this.lodgings.size();
        int hoursTillEstLeave = hoursTillLeave(nights);

        //number of hours a person is expected to spend at this location
        List<SchedulablePlace>[] schedulableHours = new LinkedList[hoursTillEstLeave];

        //loops though all of the possible hours
        for(int i = 0; i < schedulableHours.length; i++){
            int time = this.currentTime + i;
            int currentDay = this.getDayOfWeek(time);
            schedulableHours[i] = new LinkedList<>();
            schedulableHours[i].add(null);

            //adds any places that are open and are valid to the list (which is then added
            //to the array) this indictates that a place can be scheduled at this time as it is both
            //valid and open.

            //LODGE
            for(SchedulablePlace place : this.lodgings){
                if(place.getType().isAllowedTime(time * 60)){
                    schedulableHours[i].add(place);
                }
            }
            //FOOD
            for(SchedulablePlace place : this.food){
                if(place.isOpen(currentDay, time * 60) && place.getType().isAllowedTime(time * 60)){
                    schedulableHours[i].add(place);
                }
            }
            //ATTRACTION
            for(SchedulablePlace place : this.attractions){
                if(place.isOpen(currentDay, time * 60) && place.getType().isAllowedTime(time * 60)){
                    schedulableHours[i].add(place);
                }
            }
        }
        return schedulableHours;
    }

    /**
     * returns the integer value for the current day of the week given the time
     * @param time current time in hours
     * @return index of the current day
     */
    private int getDayOfWeek(int time) {
        SimpleDateFormat ft = new SimpleDateFormat("E");
        int day = getDay(ft.format(this.startDate));
        int extraDays = time / 24;
        int totalDay = day + extraDays;
        while(totalDay >= 7){
            totalDay -= 7;
        }
        return totalDay;
    }

    /**
     * Returns the index of the day given the string representation of the day
     * ie mon = 0 fri = 4
     * @param format string for the day eg 'tue'
     * @return index of the day
     */
    private int getDay(String format) {
        switch(format.toLowerCase()){
            case "mon" : {
                return 0;
            }
            case "tue" : {
                return 1;
            }
            case "wed" : {
                return 2;
            }
            case "thu" : {
                return 3;
            }
            case "fri" : {
                return 4;
            }
            case "sat" : {
                return 5;
            }
            case "sun" : {
                return 6;
            }
            default:{
                return -1;
            }
        }
    }

    /**
     * generates / creates the next permutation in the sequence given the master table
     * @return a plan for the next permutation
     */
    public Plan nextPermutation(){
        //initialises and increments all variables in the correct respects
        Random rand = new Random(this.permutation);

        List<SchedulablePlace> completedPlace = new LinkedList<>();
        SchedulablePlace[] hourlyPlan = new SchedulablePlace[this.masterTable.length];

        this.permutation++;

        int minTime = -1;

        int continueCount = 0;

        if(this.recursiveCounter > 20){
            this.recursiveCounter = 0;
            return null;
        }

        //iterates though the empty plan
        for(int i = 0; i < hourlyPlan.length; i++){
            int time = this.currentTime + i;
            if(minTime <= 0) {
                //checks that the number of 'continue's ran doesnt exceed 15 and that there are places
                //that can be scheduled at this time
                if(this.masterTable[i].size() > 0 && continueCount < 15) {
                    SchedulablePlace place = this.getRandomPlace(rand, completedPlace, SchedulerType.getTimeType(time * 60), i, hourlyPlan);

                    if(place != null) {
                        if (!completedPlace.contains(place)) {
                            //adds the place to the plan
                            minTime = place.getType().getMinTime() - 1;
                            hourlyPlan[i] = place;
                            completedPlace.add(place);
                        } else {
                            if (this.masterTable[i].size() > completedPlace.size()) {
                                //if the random place has already been used then this loop is redone
                                //with the same variables
                                i--;
                                continueCount++;
                                continue;
                            }
                            //otherwise set nothing to do at this time
                            hourlyPlan[i] = null;
                        }
                    } else {
                        //set nothing to do at this time
                        hourlyPlan[i] = null;
                    }
                } else {
                    //set nothing to do at this time
                    hourlyPlan[i] = null;
                }
            } else {
                //places require to be scheduled for a minimum time, ths checks that the previous
                //place is available at this time.
                if(this.masterTable[i].contains(hourlyPlan[i - 1])) {
                    hourlyPlan[i] = hourlyPlan[i - 1];
                    minTime--;
                } else {
                    //if it isnt then restart the whole process as the current permutation wont work
                    this.recursiveCounter++;
                    return this.nextPermutation();
                }
            }
            continueCount = 0;
            //if there has been nothing set to do at this current time and the user can be in their place
            //of lodge then set this time to be in the place of lodge
            if(hourlyPlan[i] == null && i - 1 >= 0){
                if(SchedulerType.isLodgeTime(time) && this.masterTable[i].contains(hourlyPlan[i - 1])){
                    hourlyPlan[i] = hourlyPlan[i - 1];
                }
            }
        }
        this.recursiveCounter = 0;
        return Plan.convert(this.permutation, hourlyPlan, Functions.union(new List[]{this.attractions, this.food, this.lodgings, this.subPlaces}), startTime, this.startDate);
    }

    /**
     * Picks a random place given the master table (global variable) and a number of constraints
     * @param rand random
     * @param visitedPlaces places that have been visited
     * @param timeTypes what types are allowed now
     * @param i time
     * @param hourlyPlan current plan
     * @return a place
     */
    private SchedulablePlace getRandomPlace(Random rand, List<SchedulablePlace> visitedPlaces, List<SchedulerType> timeTypes, int i, SchedulablePlace[] hourlyPlan) {
        List<SchedulablePlace> bestFitPlaces = new LinkedList<>();

        //this removes food type from the allowed types if the previous place was a food place
        if (i - 2 >= 0 && hourlyPlan[i - 2] != null && hourlyPlan[i - 2].getType() == SchedulerType.FOOD) {
            timeTypes.remove(SchedulerType.FOOD);
        }

        //get a list of places that could be ran at this time
        for(SchedulablePlace place : this.masterTable[i]){
            if(place != null && timeTypes.contains(place.getType())){
                bestFitPlaces.add(place);
            }
            //null is included in this (as you can be doing nothing)
            if(place == null){
                bestFitPlaces.add(place);
            }
        }

        //if all the places have already been done, then return null
        //else remove the done places and return a random place
        if(visitedPlaces.containsAll(bestFitPlaces)){
            return null;
        } else {
            bestFitPlaces.removeAll(visitedPlaces);
            return  bestFitPlaces.get(rand.nextInt(bestFitPlaces.size()));
        }
    }

    /**
     * returns the number of hours until its estimated that a person would leave a location
     * @param nights number of nights / hotels staying at
     * @return hours until a person would be expected to leave
     */

    private int hoursTillLeave(int nights) {
        //This is all done in hours (?rest of the project is in minutes
        if(nights == 0) { nights = 1; }
        return (24 - this.startTime) + ((nights - 1) * 24) + (SchedulerType.LODGE.getTimes()[0][1] / 60) + this.extraHours;
    }
}
